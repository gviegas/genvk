#!/usr/bin/env python3

import xml.etree.ElementTree
import sys

class Command:
    Global = 0
    Instance = 1
    Device = 2

    def __init__(self, proto, params):
        self.proto = Command.Proto(proto)
        self.params = []
        for p in params:
            self.params.append(Command.Param(p))
        self.isext = self.proto.name[-1].isupper()
        self.level = Command.Global
        if len(self.params) == 0:
            return
        s = self.params[0].typ
        if s == "VkInstance" or s == "VkPhysicalDevice":
            self.level = Command.Instance
        elif s == "VkDevice" or s == "VkQueue" or s == "VkCommandBuffer":
            if self.proto.name != "vkGetDeviceProcAddr":
                self.level = Command.Device
            else:
                # vkGetDeviceProcAddr is obtained from vkGetInstanceProcAddr
                # using a valid VkInstance handle.
                self.level = Command.Instance

    def __str__(self):
        s = str(self.proto) + "(\n    "
        n = len(self.params)
        if n > 0:
            for i in range(n-1):
               s += str(self.params[i]) + ",\n    "
            s += str(self.params[n-1])
        s += ")"
        return s

    class TypeName:
        def __init__(self, elem):
            name = elem.find("name")
            assert(name is not None and name.text is not None)
            self.name = name.text.strip()
            typ = elem.find("type")
            assert(typ is not None and typ.text is not None)
            self.typ = ""
            if elem.text is not None:
                self.typ = elem.text
            self.typ += typ.text
            if typ.tail is not None:
                self.typ += typ.tail
            self.typ = self.typ.strip()

        def __str__(self):
            return self.typ + " " + self.name

    class Proto(TypeName):
        pass

    class Param(TypeName):
        pass


header = """// Code generated by genvk.py.

#pragma once

#define VK_NO_PROTOTYPES
// TODO: Platform macros.
#include <vulkan/vulkan.h>

// Function pointers.
// TODO: Extensions.
{}
// Functions that obtain the function pointers.
// The process of obtaining the procedures for use is as follows:
//  1. Fetch the vkGetInstanceProcAddr symbol;
//  2. Call GetGlobalProcsVK;
//  3. Create a valid VkInstance and call GetInstanceProcsVK;
//  4. Create a valid VkDevice and call GetDeviceProcsVK.
{}
"""


source = """// Code generated by genvk.py.

#include <cassert>

#include "vk.h"

{}
{}
"""


def gen_getters(commands, decl):
    globl = "void GetGlobalProcsVK()"
    inst = "void GetInstanceProcsVK(VkInstance h)"
    dev = "void GetDeviceProcsVK(VkDevice h)"
    if decl:
        globl += ";"
        inst += ";"
        dev += ";"
    else:
        fp = "\n    PFN_vkVoidFunction f = nullptr;\n"
        globl += "\n{\n    assert(vkGetInstanceProcAddr);\n" + fp
        inst += "\n{\n    assert(vkGetInstanceProcAddr && h);\n" + fp
        dev += "\n{\n    assert(vkGetDeviceProcAddr && h);\n" + fp
        for cmd in commands:
            name = cmd.proto.name
            if not name.startswith("vk"):
                continue
            if name == "vkGetInstanceProcAddr":
                # vkGetInstanceProcAddr is obtained by other means.
                continue
            fmt = '    f = {}, "{}");\n    {} = reinterpret_cast<PFN_{}>(f);\n'
            if cmd.level == Command.Device:
                pre = "vkGetDeviceProcAddr(h"
                dev += fmt.format(pre, name, name, name)
            elif cmd.level == Command.Instance:
                pre = "vkGetInstanceProcAddr(h"
                inst += fmt.format(pre, name, name, name)
            else:
                pre = "vkGetInstanceProcAddr(nullptr"
                globl += fmt.format(pre, name, name, name)
        globl += "}\n"
        inst += "}\n"
        dev += "}"
    return globl + "\n" + inst + "\n" + dev


def gen_procs(commands, decl):
    procs = ""
    fmt = "extern PFN_{} {};\n" if decl else "PFN_{} {} = nullptr;\n"
    for cmd in commands:
        procs += fmt.format(cmd.proto.name, cmd.proto.name)
    return procs


def gen_commands(registry):
    cmds = registry.find("commands")
    if cmds is None:
        print("bad xml file: 'commands' element not found")
        exit()
    objs = []
    for cmd in cmds.findall("command"):
        proto = cmd.find("proto")
        if proto is None:
            continue
        params = cmd.findall("param")
        objs.append(Command(proto, params))
        # TODO: Support extensions.
        if objs[-1].isext:
            objs = objs[:-1]
    return objs


def gen(pathname):
    tree = xml.etree.ElementTree.parse(pathname)
    root = tree.getroot()
    if root is None or root.tag != "registry":
        print("bad xml file")
        exit()
    commands = gen_commands(root)
    with open("vk.h", "w") as f:
        procs = gen_procs(commands, True)
        getters = gen_getters(commands, True)
        f.write(header.format(procs, getters))
    with open("vk.cpp", "w") as f:
        procs = gen_procs(commands, False)
        getters = gen_getters(commands, False)
        f.write(source.format(procs, getters))


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("usage:\n\t{} <vk.xml>".format(sys.argv[0]))
        exit()
    pathname = sys.argv[1]
    gen(pathname)
